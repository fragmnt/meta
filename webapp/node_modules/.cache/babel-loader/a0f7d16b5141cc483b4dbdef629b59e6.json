{"ast":null,"code":"import { Emitter } from './emitter';\nimport { mapValues } from './utils';\n/**\n * Immutable snapshot of the current store state. One StoreSnapshot per\n * StoreDefinition is usually alive at a time.\n */\n\nexport class StoreSnapshot {\n  constructor(state, storeDefinition) {\n    this.state = state;\n    this.storeDefinition = storeDefinition;\n  }\n\n  get(key) {\n    return this.state[key];\n  }\n\n  set(key) {\n    return this.storeDefinition.set(key);\n  }\n\n  setFrom_EXPERIMENTAL(f) {\n    return this.storeDefinition.setFrom_EXPERIMENTAL(f);\n  }\n\n  on(key) {\n    return this.storeDefinition.on(key);\n  }\n\n  onAll() {\n    return this.storeDefinition.onAll();\n  }\n\n  getState() {\n    return Object.freeze(this.state);\n  }\n\n}\nlet DEFAULT_OPTIONS = {\n  isDevMode: false\n};\n/**\n * We create a single instance of this per <Container />.\n */\n\nexport class StoreDefinition {\n  constructor(state, options) {\n    // Initialize emitters\n    this.alls = new Emitter(options.isDevMode);\n    this.emitter = new Emitter(options.isDevMode); // Set initial state\n\n    this.storeSnapshot = new StoreSnapshot(state, this); // Cache setters\n\n    this.setters = mapValues(state, (v, key) => value => {\n      let previousValue = this.storeSnapshot.get(key);\n      this.storeSnapshot = new StoreSnapshot(Object.assign({}, this.storeSnapshot.getState(), {\n        [key]: value\n      }), this);\n      this.emitter.emit(key, value);\n      this.alls.emit(key, {\n        key,\n        previousValue,\n        value\n      });\n    });\n  }\n\n  on(key) {\n    return this.emitter.on(key);\n  }\n\n  onAll() {\n    return this.alls.all();\n  }\n\n  get(key) {\n    return this.storeSnapshot.get(key);\n  }\n\n  set(key) {\n    return this.setters[key];\n  }\n\n  setFrom_EXPERIMENTAL(f) {\n    return f(this.storeSnapshot);\n  }\n\n  getCurrentSnapshot() {\n    return this.storeSnapshot;\n  }\n\n  toStore() {\n    return this.storeSnapshot;\n  }\n\n  getState() {\n    return this.storeSnapshot.getState();\n  }\n\n}\n/**\n * @deprecated Use `createConnectedStore` instead.\n */\n\nexport function createStore(initialState, options = DEFAULT_OPTIONS) {\n  return new StoreDefinition(initialState, options);\n}\nexport * from './plugins/withLogger';\nexport * from './plugins/withReduxDevtools';\nexport * from './react';","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Emitter } from './emitter';\nimport { mapValues } from './utils';\n/**\n * Immutable snapshot of the current store state. One StoreSnapshot per\n * StoreDefinition is usually alive at a time.\n */\nexport class StoreSnapshot {\n    constructor(state, storeDefinition) {\n        this.state = state;\n        this.storeDefinition = storeDefinition;\n    }\n    get(key) {\n        return this.state[key];\n    }\n    set(key) {\n        return this.storeDefinition.set(key);\n    }\n    setFrom_EXPERIMENTAL(f) {\n        return this.storeDefinition.setFrom_EXPERIMENTAL(f);\n    }\n    on(key) {\n        return this.storeDefinition.on(key);\n    }\n    onAll() {\n        return this.storeDefinition.onAll();\n    }\n    getState() {\n        return Object.freeze(this.state);\n    }\n}\nlet DEFAULT_OPTIONS = {\n    isDevMode: false\n};\n/**\n * We create a single instance of this per <Container />.\n */\nexport class StoreDefinition {\n    constructor(state, options) {\n        // Initialize emitters\n        this.alls = new Emitter(options.isDevMode);\n        this.emitter = new Emitter(options.isDevMode);\n        // Set initial state\n        this.storeSnapshot = new StoreSnapshot(state, this);\n        // Cache setters\n        this.setters = mapValues(state, (v, key) => (value) => {\n            let previousValue = this.storeSnapshot.get(key);\n            this.storeSnapshot = new StoreSnapshot(Object.assign({}, this.storeSnapshot.getState(), { [key]: value }), this);\n            this.emitter.emit(key, value);\n            this.alls.emit(key, { key, previousValue, value });\n        });\n    }\n    on(key) {\n        return this.emitter.on(key);\n    }\n    onAll() {\n        return this.alls.all();\n    }\n    get(key) {\n        return this.storeSnapshot.get(key);\n    }\n    set(key) {\n        return this.setters[key];\n    }\n    setFrom_EXPERIMENTAL(f) {\n        return f(this.storeSnapshot);\n    }\n    getCurrentSnapshot() {\n        return this.storeSnapshot;\n    }\n    toStore() {\n        return this.storeSnapshot;\n    }\n    getState() {\n        return this.storeSnapshot.getState();\n    }\n}\n/**\n * @deprecated Use `createConnectedStore` instead.\n */\nexport function createStore(initialState, options = DEFAULT_OPTIONS) {\n    return new StoreDefinition(initialState, options);\n}\nexport * from './plugins/withLogger';\nexport * from './plugins/withReduxDevtools';\nexport * from './react';\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}