{"ast":null,"code":"import { Observable } from 'rxjs-observable';\nconst ALL = '__ALL__';\nconst CYCLE_ERROR_MESSAGE = '[undux] Error: Cyclical dependency detected. ' + 'This may cause a stack overflow unless you fix it. \\n' + 'The culprit is the following sequence of .set calls, ' + 'called from one or more of your Undux Effects: ';\nexport class Emitter {\n  constructor(isDevMode = false) {\n    this.isDevMode = isDevMode;\n    this.state = {\n      callChain: new Set(),\n      observables: new Map(),\n      observers: new Map()\n    };\n  }\n  /**\n   * Emit an event (silently fails if no listeners are hooked up yet)\n   */\n\n\n  emit(key, value) {\n    if (this.isDevMode) {\n      if (this.state.callChain.has(key)) {\n        console.error(CYCLE_ERROR_MESSAGE + Array.from(this.state.callChain).concat(key).join(' -> '));\n        return this;\n      } else {\n        this.state.callChain.add(key);\n      }\n    }\n\n    if (this.hasChannel(key)) {\n      this.emitOnChannel(key, value);\n    }\n\n    if (this.hasChannel(ALL)) {\n      this.emitOnChannel(ALL, value);\n    }\n\n    if (this.isDevMode) this.state.callChain.clear();\n    return this;\n  }\n  /**\n   * Subscribe to an event\n   */\n\n\n  on(key) {\n    return this.createChannel(key);\n  }\n  /**\n   * Subscribe to all events\n   */\n\n\n  all() {\n    return this.createChannel(ALL);\n  } ///////////////////// privates /////////////////////\n\n\n  createChannel(key) {\n    if (!this.state.observers.has(key)) {\n      this.state.observers.set(key, []);\n    }\n\n    if (!this.state.observables.has(key)) {\n      this.state.observables.set(key, []);\n    }\n\n    const observable = new Observable(_ => {\n      this.state.observers.get(key).push(_);\n      return () => this.deleteChannel(key, observable);\n    });\n    this.state.observables.get(key).push(observable);\n    return observable;\n  }\n\n  deleteChannel(key, observable) {\n    if (!this.state.observables.has(key)) {\n      return;\n    }\n\n    const array = this.state.observables.get(key);\n    const index = array.indexOf(observable);\n\n    if (index < 0) {\n      return;\n    }\n\n    array.splice(index, 1);\n\n    if (!array.length) {\n      this.state.observables.delete(key);\n      this.state.observers.delete(key);\n    }\n  }\n\n  emitOnChannel(key, value) {\n    this.state.observers.get(key).forEach(_ => _.next(value));\n  }\n\n  hasChannel(key) {\n    return this.state.observables.has(key);\n  }\n\n}","map":{"version":3,"sources":["../src/emitter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Observable } from 'rxjs-observable';\nconst ALL = '__ALL__';\nconst CYCLE_ERROR_MESSAGE = '[undux] Error: Cyclical dependency detected. ' +\n    'This may cause a stack overflow unless you fix it. \\n' +\n    'The culprit is the following sequence of .set calls, ' +\n    'called from one or more of your Undux Effects: ';\nexport class Emitter {\n    constructor(isDevMode = false) {\n        this.isDevMode = isDevMode;\n        this.state = {\n            callChain: new Set(),\n            observables: new Map(),\n            observers: new Map()\n        };\n    }\n    /**\n     * Emit an event (silently fails if no listeners are hooked up yet)\n     */\n    emit(key, value) {\n        if (this.isDevMode) {\n            if (this.state.callChain.has(key)) {\n                console.error(CYCLE_ERROR_MESSAGE +\n                    Array.from(this.state.callChain)\n                        .concat(key)\n                        .join(' -> '));\n                return this;\n            }\n            else {\n                this.state.callChain.add(key);\n            }\n        }\n        if (this.hasChannel(key)) {\n            this.emitOnChannel(key, value);\n        }\n        if (this.hasChannel(ALL)) {\n            this.emitOnChannel(ALL, value);\n        }\n        if (this.isDevMode)\n            this.state.callChain.clear();\n        return this;\n    }\n    /**\n     * Subscribe to an event\n     */\n    on(key) {\n        return this.createChannel(key);\n    }\n    /**\n     * Subscribe to all events\n     */\n    all() {\n        return this.createChannel(ALL);\n    }\n    ///////////////////// privates /////////////////////\n    createChannel(key) {\n        if (!this.state.observers.has(key)) {\n            this.state.observers.set(key, []);\n        }\n        if (!this.state.observables.has(key)) {\n            this.state.observables.set(key, []);\n        }\n        const observable = new Observable(_ => {\n            this.state.observers.get(key).push(_);\n            return () => this.deleteChannel(key, observable);\n        });\n        this.state.observables.get(key).push(observable);\n        return observable;\n    }\n    deleteChannel(key, observable) {\n        if (!this.state.observables.has(key)) {\n            return;\n        }\n        const array = this.state.observables.get(key);\n        const index = array.indexOf(observable);\n        if (index < 0) {\n            return;\n        }\n        array.splice(index, 1);\n        if (!array.length) {\n            this.state.observables.delete(key);\n            this.state.observers.delete(key);\n        }\n    }\n    emitOnChannel(key, value) {\n        this.state.observers.get(key).forEach(_ => _.next(value));\n    }\n    hasChannel(key) {\n        return this.state.observables.has(key);\n    }\n}\n//# sourceMappingURL=emitter.js.map"]},"metadata":{},"sourceType":"module"}