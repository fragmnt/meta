{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar observable_1 = require(\"./symbol/observable\");\n\nvar pipe_1 = require(\"./util/pipe\");\n\nvar toSubscriber_1 = require(\"./util/toSubscriber\");\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\n\n\nvar Observable =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  function Observable(subscribe) {\n    /** Internal implementation detail, do not use directly. */\n    this._isScalar = false;\n\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n\n\n  Observable.prototype.lift = function (operator) {\n    var observable = new Observable();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  };\n\n  Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n    var operator = this.operator;\n    var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(this.source || this._trySubscribe(sink));\n    }\n\n    return sink;\n  };\n  /** @deprecated This is an internal implementation detail, do not use. */\n\n\n  Observable.prototype._trySubscribe = function (sink) {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      sink.error(err);\n    }\n  };\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n\n\n  Observable.prototype.forEach = function (next, promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      var subscription;\n      subscription = _this.subscribe(function (value) {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    });\n  };\n  /** @deprecated This is an internal implementation detail, do not use. */\n\n\n  Observable.prototype._subscribe = function (subscriber) {\n    var source = this.source;\n    return source && source.subscribe(subscriber);\n  };\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n\n\n  Observable.prototype[observable_1.observable] = function () {\n    return this;\n  };\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ### Example\n   * ```javascript\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   * ```\n   */\n\n\n  Observable.prototype.pipe = function () {\n    var operations = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      operations[_i] = arguments[_i];\n    }\n\n    if (operations.length === 0) {\n      return this;\n    }\n\n    return pipe_1.pipeFromArray(operations)(this);\n  };\n\n  Observable.prototype.toPromise = function (promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      var value;\n\n      _this.subscribe(function (x) {\n        return value = x;\n      }, function (err) {\n        return reject(err);\n      }, function () {\n        return resolve(value);\n      });\n    });\n  };\n\n  return Observable;\n}();\n\nexports.Observable = Observable;\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\n\nfunction getPromiseCtor(promiseCtor) {\n  if (!promiseCtor) {\n    promiseCtor = Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}","map":{"version":3,"sources":["../../src/Observable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar observable_1 = require(\"./symbol/observable\");\nvar pipe_1 = require(\"./util/pipe\");\nvar toSubscriber_1 = require(\"./util/toSubscriber\");\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        /** Internal implementation detail, do not use directly. */\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this.source);\n        }\n        else {\n            sink.add(this.source || this._trySubscribe(sink));\n        }\n        return sink;\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.error(err);\n        }\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            // Must be declared in a separate statement to avoid a RefernceError when\n            // accessing subscription below in the closure due to Temporal Dead Zone.\n            var subscription;\n            subscription = _this.subscribe(function (value) {\n                try {\n                    next(value);\n                }\n                catch (err) {\n                    reject(err);\n                    if (subscription) {\n                        subscription.unsubscribe();\n                    }\n                }\n            }, reject, resolve);\n        });\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    Observable.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        return source && source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.observable] = function () {\n        return this;\n    };\n    /**\n     * Used to stitch together functional operators into a chain.\n     * @method pipe\n     * @return {Observable} the Observable result of all of the operators having\n     * been called in the order they were passed in.\n     *\n     * ### Example\n     * ```javascript\n     * import { map, filter, scan } from 'rxjs/operators';\n     *\n     * Rx.Observable.interval(1000)\n     *   .pipe(\n     *     filter(x => x % 2 === 0),\n     *     map(x => x + x),\n     *     scan((acc, x) => acc + x)\n     *   )\n     *   .subscribe(x => console.log(x))\n     * ```\n     */\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        if (operations.length === 0) {\n            return this;\n        }\n        return pipe_1.pipeFromArray(operations)(this);\n    };\n    Observable.prototype.toPromise = function (promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor) {\n    if (!promiseCtor) {\n        promiseCtor = Promise;\n    }\n    if (!promiseCtor) {\n        throw new Error('no Promise impl found');\n    }\n    return promiseCtor;\n}\n//# sourceMappingURL=Observable.js.map"]},"metadata":{},"sourceType":"script"}